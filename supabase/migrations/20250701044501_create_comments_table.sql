CREATE TABLE blog_comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    post_id BIGINT NOT NULL REFERENCES blog_posts(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    content TEXT NOT NULL CHECK (char_length(content) > 0),
    parent_comment_id BIGINT REFERENCES blog_comments(id) ON DELETE CASCADE, -- For threaded comments
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Add index for faster comment lookups
CREATE INDEX ON blog_comments (post_id);

-- RLS Policies for comments
ALTER TABLE blog_comments ENABLE ROW LEVEL SECURITY;

-- Allow public read access
CREATE POLICY "Allow public read access to comments"
ON blog_comments
FOR SELECT
USING (true);

-- Allow authenticated users to insert comments
CREATE POLICY "Allow authenticated users to insert comments"
ON blog_comments
FOR INSERT
WITH CHECK (auth.role() = 'authenticated' AND author_id = auth.uid());

-- Allow users to update their own comments
CREATE POLICY "Allow users to update their own comments"
ON blog_comments
FOR UPDATE
USING (auth.uid() = author_id);

-- Allow users to delete their own comments
CREATE POLICY "Allow users to delete their own comments"
ON blog_comments
FOR DELETE
USING (auth.uid() = author_id);

-- Import the moddatetime extension if it doesn't exist
CREATE EXTENSION IF NOT EXISTS moddatetime WITH SCHEMA extensions;

-- Trigger to update 'updated_at' timestamp
CREATE TRIGGER handle_updated_at
BEFORE UPDATE ON blog_comments
FOR EACH ROW
EXECUTE PROCEDURE extensions.moddatetime (updated_at);
